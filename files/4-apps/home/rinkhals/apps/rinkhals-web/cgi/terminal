#!/bin/sh


################
# Decode query string

urldecode() {
  # Input URL encoded string
  _encoded_url="$1"

  # Replace '+' with spaces first
  _decoded_url=""
  _c=''
  _i=0
  _len=${#_encoded_url} # This is a Bashism/Zshism. For pure ASH, need a loop for length.

  # ASH compatible way to replace '+' with spaces:
  # Using sed for portability
  _temp_url=$(echo "$_encoded_url" | sed 's/\+/ /g')

  _final_decoded=""
  _buffer=""
  _hex_char=""

  # Process character by character
  _len_temp=$(echo "$_temp_url" | wc -c) # Approx length for loop
  _j=0

  # Loop through the string, character by character
  while [ "$_j" -lt "$_len_temp" ]; do
    _char=$(echo "$_temp_url" | cut -c $((_j+1)))
    
    if [ "$_char" = "%" ]; then
      # Expecting two hex digits
      _hex_val=$(echo "$_temp_url" | cut -c $((_j+2))-$((_j+3)))
      # Convert hex to decimal, then decimal to char using printf
      # This is the tricky part without printf %b directly
      # A simple way is to use awk's printf for this, or a lookup table.
      # For a pure ASH shell without awk or perl, it's very hard directly.
      # Let's rely on a common trick: hex to char conversion via printf.
      # This still depends on printf interpreting \x, which might not be universal for all ash, but is common.
      _converted_char=$(printf '\\x%s' "$_hex_val")
      _final_decoded="${_final_decoded}$(printf '%b' "$_converted_char")" # This printf %b is the hurdle.
      _j=$((_j+2)) # Skip two hex digits
    else
      _final_decoded="${_final_decoded}${_char}"
    fi
    _j=$((_j+1))
  done

  echo "$_final_decoded"
}

urldecode_base64() {
    _encoded_b64="$1"
    _decoded_b64=$(echo "$_encoded_b64" | sed 's/%2B/+/g; s/%2F/\//g; s/%3D/=/g; s/%25/%/g')

    echo "$_decoded_b64"
}

IFS='&' 
for pair in $QUERY_STRING; do
  key=$(printf '%s' "$pair" | cut -d= -f1 | tr '[:lower:]' '[:upper:]')
  value=$(printf '%s' "$pair" | cut -d= -f2-)
  export $(echo "QUERY_STRING_$key")="$value"
done
unset IFS

#set


################
# Actions

create() {
    terminal_id=$(head -c 6 /dev/urandom | xxd -p | head -c 8)

    screen -dmS "$terminal_id" > /dev/null 2> /dev/null
    screen_status=$?

    echo "Content-Type: application/json"
    echo

    if [ $screen_status -eq 0 ]; then
        printf '{"status":"success","id":"%s"}\n' "$terminal_id"
    else
        printf '{"status":"error","message":"Failed to create screen session"}\n'
        return 1 # Indicate failure
    fi
}

delete() {
    terminal_id="$QUERY_STRING_ID"

    echo "Content-Type: application/json"
    echo

    if [ -z "$terminal_id" ]; then
        printf '{"status":"error","message":"Terminal name not provided"}\n'
        return 1
    fi

    # Check if the screen session exists before trying to kill it
    if screen -list | grep -q "$terminal_id"; then
        screen -X -S "$terminal_id" quit
        if [ $? -eq 0 ]; then
            printf '{"status":"success"}\n'
        else
            printf '{"status":"error","message":"Failed to quit screen session %s"}\n' "$terminal_id"
        fi
    else
        printf '{"status":"error","message":"Screen session %s not found"}\n' "$terminal_id"
    fi
}

resize() {
    terminal_id="$QUERY_STRING_ID"
    rows="$QUERY_STRING_ROWS"
    cols="$QUERY_STRING_COLS"

    echo "Content-Type: application/json"
    echo

    if [ -z "$terminal_id" ] || [ -z "$rows" ] || [ -z "$cols" ]; then
        printf '{"status":"error","message":"Terminal ID, rows, or columns not provided"}\n'
        return 1
    fi

    # Validate rows and cols are numbers (basic check)
    if ! echo "$rows" | grep -q '^[0-9]\+$' || ! echo "$cols" | grep -q '^[0-9]\+$'; then
        printf '{"status":"error","message":"Rows and columns must be valid numbers"}\n'
        return 1
    fi

    # Check if the screen session exists before trying to resize it
    if ! screen -list | grep -q "$terminal_id"; then
        printf '{"status":"error","message":"Screen session %s not found"}\n' "$terminal_id"
        return 1
    fi

    screen -S "$terminal_id" -X resize "$rows" "$cols" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        printf '{"status":"success","id":"%s","rows":%s,"cols":%s}\n' "$terminal_id" "$rows" "$cols"
    else
        printf '{"status":"error","message":"Failed to resize screen session %s to %sx%s"}\n' "$terminal_id" "$rows" "$cols"
    fi
}

buffer() {
    terminal_id="$QUERY_STRING_ID"
    temp_file=/tmp/rinkhals/web/rinkhals_terminal_${terminal_id}.tmp

    echo "Content-Type: application/json"
    echo

    screen -S "$terminal_id" -X hardcopy "$temp_file" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        printf '{"status":"error","message":"Failed to get hardcopy from screen session %s"}\n' "$terminal_id"
        return 1
    fi

    escaped_content=$(cat "$temp_file" | base64 -w 0)
    printf '{"status":"success","content":"%s"}\n' "$escaped_content"
}

send() {
    terminal_id="$QUERY_STRING_ID"
    keys=$(urldecode_base64 "$QUERY_STRING_KEYS" | base64 -d)

    if [ -z "$terminal_id" ]; then
        echo "Content-Type: application/json"
        echo
        printf '{"status":"error","message":"Terminal ID not provided"}\n'
        return 1
    fi
    if [ -z "$keys" ]; then
        echo "Content-Type: application/json"
        echo
        printf '{"status":"error","message":"Keys to send not provided"}\n'
        return 1
    fi
    # if ! screen -list | grep -q "$terminal_id"; then
    #     printf '{"status":"error","message":"Screen session %s not found"}\n' "$terminal_id"
    #     return 1
    # fi

    screen -S "$terminal_id" -X stuff "$keys" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        buffer
    else
        echo "Content-Type: application/json"
        echo
        printf '{"status":"error","message":"Failed to send keys to screen session %s"}\n' "$terminal_id"
    fi
}


################
# Process the action

case "${QUERY_STRING_ACTION:-x}" in
    "create")
        create
        ;;
    "delete")
        delete
        ;;
    "resize")
        resize
        ;;
    "buffer")
        buffer
        ;;
    "send")
        send
        ;;
    *)
        echo "Content-Type: application/json"
        echo
        printf '{"status":"error","message":"Unknown or missing action: %s"}\n' "$QUERY_STRING_ACTION"
        ;;
esac
